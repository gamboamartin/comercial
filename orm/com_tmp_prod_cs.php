<?php
namespace gamboamartin\comercial\models;

use base\orm\_modelo_parent;
use gamboamartin\cat_sat\models\cat_sat_producto;
use gamboamartin\direccion_postal\models\dp_calle;
use gamboamartin\direccion_postal\models\dp_calle_pertenece;
use gamboamartin\direccion_postal\models\dp_colonia;
use gamboamartin\direccion_postal\models\dp_colonia_postal;
use gamboamartin\direccion_postal\models\dp_cp;
use gamboamartin\direccion_postal\models\dp_estado;
use gamboamartin\direccion_postal\models\dp_municipio;
use gamboamartin\direccion_postal\models\dp_pais;
use gamboamartin\errores\errores;
use PDO;
use stdClass;

class com_tmp_prod_cs extends _modelo_parent{

    public function __construct(PDO $link, array $childrens = array()){
        $tabla = 'com_tmp_prod_cs';
        $columnas = array($tabla=>false);
        $campos_obligatorios = array();
        $childrens = array();
        $columnas_extra = array();


        parent::__construct(link: $link, tabla: $tabla, campos_obligatorios: $campos_obligatorios,
            columnas: $columnas, columnas_extra: $columnas_extra, childrens: $childrens);

        $this->NAMESPACE = __NAMESPACE__;

        $this->etiqueta = 'Temporales Prod';

    }

    public function alta_bd(array $keys_integra_ds = array('codigo', 'descripcion')): array|stdClass
    {

        $keys_init[] = 'cat_sat_producto';

        foreach ($keys_init as $key){
            if(!isset($this->registro[$key]) || trim($this->registro[$key]) === ''){
                $this->registro[$key] = 'PENDIENTE';
            }
        }

        if(!isset($this->registro['descripcion'])){
            $descripcion = $this->registro['com_producto_id'].' ';

            foreach ($keys_init as $key){
                $descripcion .= $this->registro[$key].' ';
            }


            $this->registro['descripcion'] = $descripcion;
        }

        $r_alta_bd = parent::alta_bd($keys_integra_ds); // TODO: Change the autogenerated stub
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al insertar',data:  $r_alta_bd);
        }
        return $r_alta_bd;
    }

    private function asigna_cat_sat_producto(array $filtro, array $tmp_upd){
        $r_cat_sat_producto = (new cat_sat_producto(link: $this->link))->filtro_and(filtro: $filtro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al validar si existe', data: $r_cat_sat_producto);
        }
        $cat_sat_producto_id = $r_cat_sat_producto->registros[0]['cat_sat_producto_id'];
        $tmp_upd['cat_sat_producto_id'] = $cat_sat_producto_id;
        return $tmp_upd;
    }


    private function existe_data_key(array $keys, stdClass $tmp): bool
    {
        $existe_data = true;
        foreach ($keys as $key){
            if(isset($tmp->$key) && (int)$tmp->$key >0 ){
                continue;
            }
            $existe_data = false;
            break;
        }
        return $existe_data;
    }



    private function integra_cat_sat_producto(array $filtro, array $tmp_upd){
        $existe_cat_sat_producto = (new cat_sat_producto(link: $this->link))->existe(filtro: $filtro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al validar si existe', data: $existe_cat_sat_producto);
        }
        if($existe_cat_sat_producto){
            $tmp_upd = $this->asigna_cat_sat_producto(filtro: $filtro, tmp_upd: $tmp_upd);
            if(errores::$error){
                return $this->error->error(mensaje: 'Error al validar si existe', data: $tmp_upd);
            }
        }
        return $tmp_upd;
    }

    public function modifica_bd(array $registro, int $id, bool $reactiva = false, array $keys_integra_ds = array('codigo', 'descripcion')): array|stdClass
    {

        $entidades = array();
        $entidades['cat_sat_producto'] = new cat_sat_producto(link: $this->link);

        foreach ($entidades as $entidad){
            $key_id = $entidad->tabla.'_id';
            $key_descripcion = $entidad->tabla.'_descripcion';

            if(isset($registro[$key_id]) && (int)$registro[$key_id] > 1){
                $row_dp = $entidad->registro(registro_id: $registro[$key_id]);
                if(errores::$error){
                    return $this->error->error(mensaje: 'Error al obtener row_dp',data:  $row_dp);
                }
                $registro[$entidad->tabla] = $row_dp[$key_descripcion];
            }
        }


        $r_modifica_bd = parent::modifica_bd(registro: $registro,id:  $id,reactiva:  $reactiva,keys_integra_ds:  $keys_integra_ds); // TODO: Change the autogenerated stub
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al r_modifica_bd',data:  $r_modifica_bd);
        }
        return $r_modifica_bd;
    }

    /**
     * Asigna los elementos para modificacion de un registro
     * @param array $cat_sat_producto
     * @return array
     */
    private function tmp_upd(array $cat_sat_producto): array
    {
        $tmp_upd['cat_sat_producto_id'] = $cat_sat_producto['cat_sat_producto_id'];
        return $tmp_upd;
    }



    private function tmp_upd_cat_sat_producto(stdClass $tmp, array $tmp_upd){
        $keys = array();
        $keys[] = 'cat_sat_producto_id';


        $existe_data_cat_sat_producto = $this->existe_data_key(keys: $keys,tmp: $tmp);
        if (errores::$error) {
            return $this->error->error(mensaje: 'Error al validar si existe data', data: $existe_data_cat_sat_producto);
        }


        if($existe_data_cat_sat_producto){
            $filtro = array();
            $filtro['cat_sat_producto.id'] = $tmp->cat_sat_producto_id;

            $tmp_upd = $this->integra_cat_sat_producto(filtro: $filtro, tmp_upd: $tmp_upd);
            if(errores::$error){
                return $this->error->error(mensaje: 'Error al validar si existe', data: $tmp_upd);
            }

        }
        return $tmp_upd;
    }


    private function tmp_upd_data(stdClass $tmp){
        $tmp_upd = array();

        $tmp_upd = $this->tmp_upd_cat_sat_producto(tmp: $tmp, tmp_upd: $tmp_upd);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al validar si existe', data: $tmp_upd);
        }
        return $tmp_upd;
    }

    private function update_regenera(stdClass $tmp, int $com_tmp_prod_cs_id){
        $tmp_upd = $this->tmp_upd_data(tmp: $tmp);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al validar si existe', data: $tmp_upd);
        }

        $upd = $this->modifica_bd(registro: $tmp_upd,id: $com_tmp_prod_cs_id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al regenerar',data:  $upd);
        }
        return $upd;
    }

    private function upd_producto(stdClass $tmp){
        $com_producto_ins['cat_sat_producto_id'] = $tmp->cat_sat_producto_id;
        $r_com_producto = (new com_producto(link: $this->link))->modifica_bd(registro: $com_producto_ins, id: $tmp->com_producto_id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al actualizar r_com_producto',data:  $r_com_producto);
        }
        return $r_com_producto;
    }

    private function ajusta_producto_regeneracion(int $com_tmp_prod_cs_id, stdClass $tmp){
        $r_com_producto = $this->upd_producto(tmp: $tmp);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al actualizar com_cliente',data:  $r_com_producto);
        }
        $del = $this->elimina_bd(id: $com_tmp_prod_cs_id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al eliminar temporal',data:  $del);
        }
        return $del;
    }

    private function ajusta_data_producto(int $com_tmp_prod_cs_id, stdClass $tmp){
        $keys = array();
        $keys[] = 'cat_sat_producto_id';

        $existe_full = $this->existe_data_key(keys: $keys,tmp: $tmp);
        if (errores::$error) {
            return $this->error->error(mensaje: 'Error al validar si existe data', data: $existe_full);
        }

        if($existe_full){
            $regenera_cte = $this->ajusta_producto_regeneracion(com_tmp_prod_cs_id: $com_tmp_prod_cs_id, tmp: $tmp);
            if(errores::$error){
                return $this->error->error(mensaje: 'Error al eliminar temporal',data:  $regenera_cte);
            }
        }

        return $existe_full;

    }

    final public function regenera(int $com_tmp_prod_cs_id){
        $tmp = $this->registro(registro_id: $com_tmp_prod_cs_id, columnas_en_bruto: true, retorno_obj: true);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener tmp',data:  $tmp);
        }

        $upd = $this->update_regenera(tmp: $tmp,com_tmp_prod_cs_id: $com_tmp_prod_cs_id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al regenerar',data:  $upd);
        }

        $regenera_cte = $this->ajusta_data_producto(com_tmp_prod_cs_id: $com_tmp_prod_cs_id, tmp: $tmp);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al eliminar temporal',data:  $regenera_cte);
        }

        $data = new stdClass();
        $data->upd = $upd;
        $data->regenera_cte = $regenera_cte;
        return $data;
    }


}