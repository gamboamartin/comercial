<?php
namespace gamboamartin\comercial\models;

use base\orm\_modelo_parent;
use gamboamartin\cat_sat\models\cat_sat_producto;
use gamboamartin\errores\errores;
use PDO;
use stdClass;

class com_tmp_prod_cs extends _modelo_parent{

    public function __construct(PDO $link, array $childrens = array()){
        $this->es_sincronizable = true;
        $tabla = 'com_tmp_prod_cs';
        $columnas = array($tabla=>false,'com_producto'=>$tabla,'cat_sat_producto'=>$tabla);
        $campos_obligatorios = array();
        $childrens = array();
        $columnas_extra = array();


        parent::__construct(link: $link, tabla: $tabla, campos_obligatorios: $campos_obligatorios,
            columnas: $columnas, columnas_extra: $columnas_extra, childrens: $childrens);

        $this->NAMESPACE = __NAMESPACE__;

        $this->etiqueta = 'Temporales Prod';

    }

    public function alta_bd(array $keys_integra_ds = array('codigo', 'descripcion')): array|stdClass
    {

        $keys_init[] = 'cat_sat_producto';

        foreach ($keys_init as $key){
            if(!isset($this->registro[$key]) || trim($this->registro[$key]) === ''){
                $this->registro[$key] = 'PENDIENTE';
            }
        }

        if(!isset($this->registro['descripcion'])){
            $descripcion = $this->registro['com_producto_id'].' ';

            foreach ($keys_init as $key){
                $descripcion .= $this->registro[$key].' ';
            }


            $this->registro['descripcion'] = $descripcion;
        }

        $r_alta_bd = parent::alta_bd($keys_integra_ds); // TODO: Change the autogenerated stub
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al insertar',data:  $r_alta_bd);
        }
        return $r_alta_bd;
    }

    /**
     * Asigna el id del producto del sat para producto comercial
     * @param array $filtro filtro a integrar
     * @param array $tmp_upd arreglo previo para actualizacion
     * @return array
     */
    private function asigna_cat_sat_producto(array $filtro, array $tmp_upd): array
    {
        $r_cat_sat_producto = (new cat_sat_producto(link: $this->link))->filtro_and(filtro: $filtro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al validar si existe', data: $r_cat_sat_producto);
        }
        $cat_sat_producto_id = $r_cat_sat_producto->registros[0]['cat_sat_producto_id'];
        $tmp_upd['cat_sat_producto_id'] = $cat_sat_producto_id;
        return $tmp_upd;
    }


    /**
     * Verifica si existe key temporal para actualizacion
     * @param array $keys
     * @param stdClass $tmp
     * @return bool
     */
    private function existe_data_key(array $keys, stdClass $tmp): bool
    {
        $existe_data = true;
        foreach ($keys as $key){
            if(isset($tmp->$key) && (int)$tmp->$key >0 ){
                continue;
            }
            $existe_data = false;
            break;
        }
        return $existe_data;
    }


    /**
     * Verifica si existe le producto del sat en base de datos conforme al filtro
     * @param array $filtro filtro para integracion
     * @param array $tmp_upd arreglo previamente cargado para la actualizacion del producto
     * @return array
     */
    private function integra_cat_sat_producto(array $filtro, array $tmp_upd): array
    {
        $existe_cat_sat_producto = (new cat_sat_producto(link: $this->link))->existe(filtro: $filtro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al validar si existe', data: $existe_cat_sat_producto);
        }
        if($existe_cat_sat_producto){
            $tmp_upd = $this->asigna_cat_sat_producto(filtro: $filtro, tmp_upd: $tmp_upd);
            if(errores::$error){
                return $this->error->error(mensaje: 'Error al validar si existe', data: $tmp_upd);
            }
        }
        return $tmp_upd;
    }

    public function modifica_bd(array $registro, int $id, bool $reactiva = false, array $keys_integra_ds = array('codigo', 'descripcion')): array|stdClass
    {

        $entidades = array();
        $entidades['cat_sat_producto'] = new cat_sat_producto(link: $this->link);

        foreach ($entidades as $entidad){
            $key_id = $entidad->tabla.'_id';
            $key_codigo = $entidad->tabla.'_codigo';

            if(isset($registro[$key_id]) && (int)$registro[$key_id] > 1){
                $row_cat_sat = $entidad->registro(registro_id: $registro[$key_id]);
                if(errores::$error){
                    return $this->error->error(mensaje: 'Error al obtener row_dp',data:  $row_cat_sat);
                }
                $registro[$entidad->tabla] = $row_cat_sat[$key_codigo];
            }
        }


        $r_modifica_bd = parent::modifica_bd(registro: $registro,id:  $id,reactiva:  $reactiva,keys_integra_ds:  $keys_integra_ds); // TODO: Change the autogenerated stub
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al r_modifica_bd',data:  $r_modifica_bd);
        }
        return $r_modifica_bd;
    }

    /**
     * Asigna los elementos para modificacion de un registro
     * @param array $cat_sat_producto
     * @return array
     */
    private function tmp_upd(array $cat_sat_producto): array
    {
        $tmp_upd['cat_sat_producto_id'] = $cat_sat_producto['cat_sat_producto_id'];
        return $tmp_upd;
    }



    private function tmp_upd_cat_sat_producto(stdClass $tmp, array $tmp_upd){
        $cat_sat_producto_codigo = $tmp->cat_sat_producto;

        $filtro['cat_sat_producto.codigo'] = $cat_sat_producto_codigo;

        $existe_cat_sat_producto = (new cat_sat_producto(link: $this->link))->existe(filtro: $filtro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al validar si existe',data:  $existe_cat_sat_producto);
        }


        if($existe_cat_sat_producto) {
            $tmp_upd = $this->get_tmp_cat_sat_producto(filtro: $filtro);
            if (errores::$error) {
                return $this->error->error(mensaje: 'Error al asignar tmp_upd', data: $tmp_upd);
            }
        }
        return $tmp_upd;
    }


    private function tmp_upd_data(stdClass $tmp){
        $tmp_upd = array();

        $tmp_upd = $this->tmp_upd_cat_sat_producto(tmp: $tmp, tmp_upd: $tmp_upd);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al validar si existe', data: $tmp_upd);
        }
        return $tmp_upd;
    }

    private function update_regenera(stdClass $tmp, int $com_tmp_prod_cs_id){
        $tmp_upd = $this->tmp_upd_data(tmp: $tmp);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al validar si existe', data: $tmp_upd);
        }

        $upd = $this->modifica_bd(registro: $tmp_upd,id: $com_tmp_prod_cs_id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al regenerar',data:  $upd);
        }
        return $upd;
    }

    private function upd_producto(stdClass $tmp){
        $com_producto_ins['cat_sat_producto_id'] = $tmp->cat_sat_producto_id;
        $r_com_producto = (new com_producto(link: $this->link))->modifica_bd(registro: $com_producto_ins, id: $tmp->com_producto_id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al actualizar r_com_producto',data:  $r_com_producto);
        }
        return $r_com_producto;
    }

    private function ajusta_producto_regeneracion(int $com_tmp_prod_cs_id, stdClass $tmp){
        $r_com_producto = $this->upd_producto(tmp: $tmp);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al actualizar com_cliente',data:  $r_com_producto);
        }
        $del = $this->elimina_bd(id: $com_tmp_prod_cs_id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al eliminar temporal',data:  $del);
        }
        return $del;
    }

    private function ajusta_data_producto(int $com_tmp_prod_cs_id, stdClass $tmp){
        $keys = array();
        $keys[] = 'cat_sat_producto_id';

        $existe_full = $this->existe_data_key(keys: $keys,tmp: $tmp);
        if (errores::$error) {
            return $this->error->error(mensaje: 'Error al validar si existe data', data: $existe_full);
        }

        if($existe_full){
            $regenera_cte = $this->ajusta_producto_regeneracion(com_tmp_prod_cs_id: $com_tmp_prod_cs_id, tmp: $tmp);
            if(errores::$error){
                return $this->error->error(mensaje: 'Error al eliminar temporal',data:  $regenera_cte);
            }
        }

        return $existe_full;

    }

    private function get_cat_sat_producto(array $filtro){
        $r_cat_sat_producto = (new cat_sat_producto(link: $this->link))->filtro_and(filtro: $filtro);
        if (errores::$error) {
            return $this->error->error(mensaje: 'Error al obtener r_cat_sat_producto', data: $r_cat_sat_producto);
        }
        if($r_cat_sat_producto->n_registros === 0){
            return $this->error->error(mensaje: 'Error no existe r_cat_sat_producto', data: $r_cat_sat_producto);
        }
        return $r_cat_sat_producto->registros[0];
    }

    private function get_tmp_cat_sat_producto(array $filtro){
        $cat_sat_producto = $this->get_cat_sat_producto(filtro: $filtro);
        if (errores::$error) {
            return $this->error->error(mensaje: 'Error al obtener tmp_upd', data: $cat_sat_producto);
        }
        $tmp_upd = $this->tmp_upd(cat_sat_producto: $cat_sat_producto);
        if (errores::$error) {
            return $this->error->error(mensaje: 'Error al asignar tmp_upd', data: $tmp_upd);
        }
        return $tmp_upd;
    }

    final public function regenera(int $com_tmp_prod_cs_id){
        $tmp = $this->registro(registro_id: $com_tmp_prod_cs_id, columnas_en_bruto: true, retorno_obj: true);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener tmp',data:  $tmp);
        }

        $upd = $this->update_regenera(tmp: $tmp,com_tmp_prod_cs_id: $com_tmp_prod_cs_id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al regenerar',data:  $upd);
        }

        $regenera_prod = $this->ajusta_data_producto(com_tmp_prod_cs_id: $com_tmp_prod_cs_id, tmp: $tmp);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al eliminar temporal',data:  $regenera_prod);
        }

        $data = new stdClass();
        $data->upd = $upd;
        $data->regenera_prod = $regenera_prod;
        return $data;
    }

    private function regenera_base(array $filtro){
        $r_com_tmp_prod_cs = $this->filtro_and(filtro: $filtro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener temporal',data:  $r_com_tmp_prod_cs);
        }
        $com_tmp_prod_cs = $r_com_tmp_prod_cs->registros[0];

        $regenera = $this->regenera(com_tmp_prod_cs_id: $com_tmp_prod_cs['com_tmp_prod_cs_id']);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al regenerar temporal',data:  $regenera);
        }
        return $regenera;
    }

    final public function regenera_por_producto(int $com_producto_id){
        $regenera = new stdClass();
        $filtro['com_producto.id'] = $com_producto_id;
        $existe_tmp = $this->existe(filtro: $filtro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al validar si existe',data:  $existe_tmp);
        }
        if($existe_tmp){
            $regenera = $this->regenera_base(filtro: $filtro);
            if(errores::$error){
                return $this->error->error(mensaje: 'Error al regenerar temporal',data:  $regenera);
            }
        }
        return $regenera;
    }


}